\chapter{Sequences and Series}

\section{Introduction}

In this lab, we will apply for loops to study sequences and series.
If you already have programming experience, you can complete the
challenge problem in lieu of the other problems.

\section{Preparation}

This lab will rely on the material from Sections 1.2.1 to 1.2.4 of the
Scientific Python Lecture notes.  Most of the problems can be
completed using a simple functions containg a single for loop, such as
in this function:
\begin{python}
  def loop(n):
    for i in range(n):
        print(i)
\end{python}
To run the code in the function, you call function, usually in a different cell:
\begin{python}
loop(5)
\end{python}

\vskip 0.25cm
\plot Create a new function:
\begin{python}
def powers(a,n):
   # your code here ...
\end{python}
that prints the first n powers of a.  For example \pyth{mult(3,4)} should output:
\begin{python}
1
3
6
9
\end{python}
In future problems, we'll describe this output simply as 1, 3, 6, 9.
We won't be picky about whitespace unless we discuss it explicitly.
One way to complete this is to use the three options of
\pyth{range(start,stop,step)}.

\section{Fibonacci Sequence}

The Fibonacci numbers are a sequence of numbers satisfying the
recursion relationship:
\begin{displaymath}
F_{n+2} = F_{n} + F_{n+1}
\end{displaymath}
with $F_0=0$ and $F_1=1$.  The sequence is:
\begin{displaymath}
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, \ldots
\end{displaymath}
This sequence can be generated numerically by an algorithm such as this one:
\begin{algorithm}
fa := 0 # set fa to 0
fb := 1 # set fb to 1
repeat n times: 
   fc := fa + fb
   print fc to screen
   fa := fb
   fb := fc
\end{algorithm}
Note that this is not python syntax.  What is the importance of the
last two lines?  Would the algorithm work if we exchanged their order?\\

\plot Use the algorithm described above to implement a new function
\pyth{fib(n)} which prints the next $n$ Fibbonacci numbers after the
initial 0 and 1.\\

\section{Arithmetic Series}

The finite arithmetic series
\begin{displaymath}
  S_n = \sum_{k=0}^{n} (a + kd) = a + (a+d) + (a+2d) + \ldots + (a+nd)
\end{displaymath}
sums to the average of the first and last terms times the number of terms:
\begin{equation} \label{eqn:arithsum}
S_n = (n+1)\frac{a + (a+nd)}{2}
\end{equation}
We will assume $a=d=1$ and calculate this finite series numerically using the following function:
\begin{python}
def arith(n):
    sum = 0
    for j in range(1,n+1):
        sum = sum + j
        #print("j: ", j, "\t sum: ", sum)
    return sum    
\end{python}
Type in this function and see how it works by uncommenting the print
statement (delete the \# symbol that starts a comment) and calling it
as \pyth{arith(5)}.  The use of print statements in a loop like this
or at each stage of a calculation is a simple, effective and classic
debugging technique.  You test your code with the print statements
included, keeping n small so you don't fill your whole screen with
output. Once your code is working, you comment out the unneeded print
statements so that the interpreter ignores them and you no longer
see the unneeded output.  Why not just delete them?  You can, but
experience shows that if you do, you will need the line again shortly!\\

\plot Obtain the sum of the first $n$ terms of arithmetic series with
\pyth{sum = arith(n)} for three different values of $n$.  Each time,
show that sum returned by the function matches the expected sum.

\section{Geometric Series}
\label{sec:geom}

The geometric series
\begin{displaymath}
  \sum_{k=0}^{\infty} a r^k = a + ar + ar^2 + ar^3 + \ldots
\end{displaymath}
converges for $|r| < 1$ to:
\begin{equation} \label{eqn:geomsum}
  \frac{a}{1-r}.
\end{equation}
We will demonstrate this numerically.\\

\plot Implement a function \pyth{geom(a,r,n)} which calculates sum of the first $n$ terms of the geometric series with $k$th term $a r^k$.  Show that it agrees with Eqn.~\ref{eqn:geomsum} for $a=2$, $r=0.5$  $n=100$.
\\

\plot Call you geometric series function again for $a=3$, $r=0.8$ and $n=100$.  Compare with the expected output calculate within python and with pencil and paper.  Do they agree exactly?  If not, do they agree within the floating point precision?
\\

\plot Now compare your calculated sum with Eqn.~\ref{eqn:geomsum} for $a=1$, $r=-0.9$  $n=100$.  How is the agreement?  Increase $n$ and see what happens.  Why do you suppose this series is slower to converge?\\

\section{Refinements}

There are a few refinements you can make to your code.  Don't change
your working code from previous examples!  Instead, copy the previous
version to a new cell and make your refinements there.  You don't even
need to change the name of the function, Python will happily overwrite
the old function implementation when it reaches the cell with the new
version.  Make these code improvements:\\

\plot (Optional) Improve your Fibbonacci function so that prints the
first $n$ numbers including the initital two numbers ``0'' and ``1''.
Make sure it works properly for $n=0$, $n=1$, $n=2$, and so on.\\

\plot (Optional) Extend the Arithmetic series function to include
parameters $a$ and $d$.  Show that it works.\\

\section{Fibonacci Integer Right Triangles}

Starting with the number 5, every second Fibonacci number is the
length of the hypotenuse of a right triangle with integer sides.  The
first two are:
\begin{displaymath}
5^2 = 3^2 + 4^2  
\end{displaymath}
and 
\begin{displaymath}
13^2 = 5^2 + 12^2.  
\end{displaymath}
Furthermore, from the second triangle onward, the middle side is the sum of the lengths of the sides of the previous triangle, for example:
\begin{displaymath}
12 = 3 + 4 + 5.  
\end{displaymath}

\vskip 0.25cm
\plot (Optional Challenge) Use numerical methods to
explicitly verify these properties for the first $n$ Fibonacci integer
right triangles.\\

If you would prefer, you may submit the Optional Challenge problem plus the
problems from Section~\ref{sec:geom} to complete the assignment.
